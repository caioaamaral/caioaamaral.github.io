<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Montague Grammar</title>

    <!-- Open Graph Meta Tags -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Montague Grammar">
    <meta property="og:description" content="">
    <meta property="og:image" content="https://caioaamaral.github.io">
    <meta property="og:url" content="https://caioaamaral.github.io/v4/posts/montague-grammar/">
    <meta property="og:site_name" content="My GitHub Pages Site">

    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i"
        rel="stylesheet">

    <!-- Boxicons -->
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>

    <link rel="stylesheet" href="/assets/css/post.css">
</head>

<body>
    <div class="flex-container">
        <aside class="sidebar">
    <div class="profile">
        <img src="/assets/avatar.jpeg">
        <h1 class="name">Caio Amaral</h1>
        <nav class="nav-menu">
            <ul>
                <li>
                    <a href="/v4">
                        <i class="bx bx-home"></i>
                        <span>Home</span>
                    </a>
                </li>
                <li>
                    <a href="/v4/about/">
                        <i class="bx bx-user"></i>
                        <span>About</span>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</aside>
        <main class="main-content">
            <article class="post-entry">
                <h1 class="title">Montague Grammar</h1>
                <span class="author">
                    Caio Amaral
                </span>
                <span class="date">
                   on September 29
                </span>
                <div class="content">
                    
                    <p>some reflections on how to generate proper semantics and why <em>syntatic</em> data is important</p>

<h3 id="the-problem-of-syntax">The problem of Syntax</h3>
<p>Grammar is the intrisic set of rules that governs sentence formation. It acts as a device that can generate all the correct sentences of a idiom. At least, that is what applies to syntax. But what could we achieve if we could generate all the correct <em>semantics</em> of a language?</p>

<p>Hallucination is one of the most disturbing problem with LLMs nowadays. When they lack relevant information, absurdities are generated - in very convincing and proper English.While the sentences are all very well structured syntactically, the semantics are pure garbage.</p>

<p>But if one can reason about <em>correct</em> and <em>incorrect</em> semantics, there must be a grammar that sets what is a meaningfull sentence in a language. And that is not a brand-new idea.</p>

<h3 id="montague-grammar">Montague Grammar</h3>
<p>In the late 1960s, the logician Richard Montague, drawing upon Chomsky Generative Grammar principles, proposed that any natural language could be approached as a formal language. In that way, one could extract meaning from a sentence using mathematical logical tooling, such as lambda calculus and type theory.</p>

<p>To summarize, the Montague Grammar consists of three core concepts:</p>
<ul>
  <li><strong>Compositionality</strong>: meaning is not holistic; a sentence’s meaning comes from the meaning of its parts.</li>
  <li><strong>Type Theory</strong>: this is a first dive into Ontology, a framework that assigns types such as entities, functions and predicates to linguistic expressions.</li>
  <li><strong>Lambda Calculus</strong>: a formal language that can be used to express computation in a functional programmatic way.</li>
</ul>

<p>It is interesting how it builds on top of synstax, by using what we nowadays call part-of-speach (POS) tagging to attribue certain types. For example, given a lexicon for “Alice loves Bob” in X-bar diagram:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          S
         / \
      NP   VP
      |    / \
    Alice V  NP
          |    \
         loves Bob
</code></pre></div></div>

<p>We have the noun phrases (NP) representing entities and the verb phrase (VP) expressing a truth value relation. Being <em>love</em> a transitive verb, it is treated as a function that takes an object and returns a function that takes a subject, ultimately yelding a truth value inference based on previous knowledge.</p>

<p>In lambda calculus notation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loves = λy.λx.loves(x,y)
</code></pre></div></div>

<p>Or in Python</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loves</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">subj</span><span class="p">:</span> <span class="p">(</span><span class="n">subj</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{(</span><span class="sh">'</span><span class="s">John</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Mary</span><span class="sh">'</span><span class="p">),</span> <span class="p">(</span><span class="sh">'</span><span class="s">Mary</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bob</span><span class="sh">'</span><span class="p">),</span> <span class="p">(</span><span class="sh">'</span><span class="s">Bob</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Mary</span><span class="sh">'</span><span class="p">)}</span>

<span class="nf">loves</span><span class="p">(</span><span class="n">Bob</span><span class="p">)(</span><span class="n">Alice</span><span class="p">)</span>

<span class="c1"># yields true for "Alice loves Bob"
# where the set of tuples represents the previous knowledge we have about 'loves'
</span>
</code></pre></div></div>

<p>We can go even further, increasing the definitions relationships. For example let’s analyse the sentences: “every man smilles” and “some man smilles”.</p>

<p>In the given sentences, “every” and “some” represents a quantifiers. They operate a nominal phrase, like “man”, by testing all its individuals againts a predicate (in this case “smiles”). On the other hand, “man” is a predicate that that test for the individuals that are male.</p>

<p>To simplify, let’s represent all that in Python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">individuals</span> <span class="o">=</span> <span class="sh">'</span><span class="s">John</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bob</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Mary</span><span class="sh">'</span>

<span class="k">def</span> <span class="nf">every</span><span class="p">(</span><span class="n">NP</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">VP</span><span class="p">:</span> <span class="nf">all</span><span class="p">(</span><span class="nc">VP</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">individuals</span> <span class="k">if</span> <span class="nc">NP</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">some</span><span class="p">(</span><span class="n">NP</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">VP</span><span class="p">:</span> <span class="nf">any</span><span class="p">(</span><span class="nc">VP</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">individuals</span> <span class="k">if</span> <span class="nc">NP</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">man</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">{</span><span class="sh">'</span><span class="s">John</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Bob</span><span class="sh">'</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">smiles</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">{</span><span class="sh">'</span><span class="s">John</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Mary</span><span class="sh">'</span><span class="p">}</span>

<span class="nf">every</span><span class="p">(</span><span class="n">man</span><span class="p">)(</span><span class="n">smiles</span><span class="p">)</span> <span class="c1"># False, since Bob doesn't smile
</span><span class="nf">some</span><span class="p">(</span><span class="n">man</span><span class="p">)(</span><span class="n">smiles</span><span class="p">)</span> <span class="c1"># True
</span></code></pre></div></div>

<h3 id="limitations-of-the-grammar-approach">Limitations of the Grammar approach</h3>

<p>Natural languages consists of variations and ambiguities, making a such rigid approach difficult (if not impossible) tto apply properly to all the sentences a language can generate. Still, it is a good first step in the search for semantic construction and ontology.</p>

                </div>
            </article>
        </main>
    </div>
</body>

</html>
